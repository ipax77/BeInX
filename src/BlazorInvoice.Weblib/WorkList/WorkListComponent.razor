@using BlazorInvoice.Shared
@using BlazorInvoice.Shared.Interfaces
@using BlazorInvoice.Weblib.Modals
@using BlazorInvoice.Weblib.Services
@using Microsoft.JSInterop
@using pax.BBToast;
@inherits InvoiceBaseComponent
@inject IInvoiceRepository InvoiceRepository
@inject IWorkListRepository WorkListRepository
@inject IJSRuntime JSRuntime
@inject IToastService ToastService

<h3>Work List</h3>
@if (workListService.CanUndoParty(partyId))
{
    <i class="bi bi-arrow-90deg-left ms-2 text-warning pointer"
       title="Undo"
       @onclick="() => UndoParty(partyId)"></i>
}
@if (workListService.CanRedoParty(partyId))
{
    <i class="bi bi-arrow-90deg-right ms-2 text-success pointer"
       title="Redo"
       @onclick="() => RedoParty(partyId)"></i>
}

<div>
    <div>
        <ul class="nav nav-tabs">
            @foreach (var party in tabParties)
            {
                <li class="nav-item">
                    <button class="nav-link @(party.PartyId == partyId ? "active" : "")"
                            @onclick="() => partyId = party.PartyId">
                        @party.Name
                        <i class="bi bi-x text-danger pointer" @onclick:stopPropagation @onclick="e => RemoveParty(party)"></i>
                    </button>

                </li>
            }
            @if (tabParties.Count == 0)
            {
                <li>
                    <button type="button" class="btn btn-outline-light" @onclick="e => buyerSelectModal?.Show()">
                        <i class="bi bi-plus-circle pointer ms-2"></i>
                        @Loc["Add Party Tab"]"
                    </button>
                </li>
            }
            else
            {
                <li><i class="bi bi-plus-circle pointer ms-2" @onclick="e => buyerSelectModal?.Show()"></i></li>
            }
        </ul>
    </div>

    @foreach (var party in tabParties)
    {
        <div class="tab-content @(party.PartyId == partyId ? "show active" : "visually-hidden")">
            <WorkEntriesComponent @ref="workEntriesComponents[party.PartyId]"
                                  DtoWorkEntries="workListService.GetEntriesByParty(party.PartyId)"
                                  PartyId="@party.PartyId"
                                  ColumnCount="@columnCount"
                                  OnFieldChanged="FieldChanged"
                                  OnDelete="DeleteEntry" />
        </div>
    }
</div>

<div>
    <DebugWorkList @ref="debugWorkList" />
</div>

<BuyerSelectModal @ref="buyerSelectModal" Parties="parties"
                  OnSelected="PartySelected" />

@code {
    int columnCount = 5;
    List<PartyListDto> parties = [];
    List<PartyListDto> tabParties = [];
    int partyId = 0;
    int currentPartyId = 0;
    bool hasTempEntries;
    Lock updateLock = new();

    HashSet<Guid> savedGuids = [];
    BuyerSelectModal? buyerSelectModal;
    DebugWorkList? debugWorkList;
    WorkListService workListService = new(new());
    Dictionary<int, WorkEntriesComponent?> workEntriesComponents = [];

    protected override async Task OnInitializedAsync()
    {
        parties = await InvoiceRepository.GetBuyers(new());
        await LoadSnapShot();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("registerCustomKeydownEvent");
        }
    }

    private async Task LoadSnapShot()
    {
        var workEntrySnapShot = await WorkListRepository.GetWorkEntries();
        workListService.SetSnapshot(workEntrySnapShot);
    }

    private void PartySelected(int selectedPartyId)
    {
        var party = parties.FirstOrDefault(p => p.PartyId == selectedPartyId);
        if (party is null)
        {
            return;
        }
        var tabParty = tabParties.FirstOrDefault(p => p.PartyId == selectedPartyId);
        if (tabParty == null)
        {
            if (!workEntriesComponents.ContainsKey(selectedPartyId))
            {
                workEntriesComponents.Add(selectedPartyId, null);
            }
            tabParties.Add(party);
        }
        partyId = selectedPartyId;
        InvokeAsync(StateHasChanged);
    }

    private void RemoveParty(PartyListDto party)
    {
        if (tabParties.Contains(party))
        {
            tabParties.Remove(party);
            if (partyId == party.PartyId)
            {
                partyId = tabParties.FirstOrDefault()?.PartyId ?? 0;
            }
        }
    }

    private async Task FieldChanged(WorkEntryWeb entry)
    {
        var dto = entry.GetDto();

        lock (updateLock)
        {
            var existingEntries = workListService.GetEntriesByParty(dto.PartyId);
            var existing = existingEntries.FirstOrDefault(e => e.EntryGuid == dto.EntryGuid);

            if (existing == null)
            {
                workListService.EntryCreated(dto);
            }
            else
            {
                workListService.EntryChanged(dto);
            }
        }
        Debug();
    }

    private void DeleteEntry(WorkEntryWeb entry)
    {
        var dto = entry.GetDto();
        workListService.EntryDeleted(dto);
        Debug();
    }

    private void UndoParty(int partyId)
    {
        var delta = workListService.UndoLastChange(partyId);
        if (delta is not null)
        {
            if (workEntriesComponents.TryGetValue(partyId, out var component))
            {
                component?.Update(delta);
            }
            StateHasChanged();
        }
        Debug();
    }

    private void RedoParty(int partyId)
    {
        var delta = workListService.RedoLastChange(partyId);
        if (delta is not null)
        {
            if (workEntriesComponents.TryGetValue(partyId, out var component))
            {
                component?.Update(delta);
            }
        }
        Debug();
    }

    private void Debug()
    {
        var snapshot = workListService.GetSnapshot();
        var entries = snapshot.EntriesByParty
            .SelectMany(kvp => kvp.Value)
            .ToList();
        debugWorkList?.Update(entries);
    }

    private async Task SaveEntries()
    {
        await WorkListRepository.SaveWorkEntries(workListService.GetSnapshot());
        ToastService.ShowSuccess(Loc["Work entries saved successfully."]);
    }
}