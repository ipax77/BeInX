@using BlazorInvoice.Shared
@using BlazorInvoice.Shared.Interfaces
@using BlazorInvoice.Weblib.Modals
@using BlazorInvoice.Weblib.Services
@using Microsoft.JSInterop
@using pax.BBToast;
@inherits InvoiceBaseComponent
@inject IInvoiceRepository InvoiceRepository
@inject IWorkListRepository WorkListRepository
@inject IJSRuntime JSRuntime
@inject IToastService ToastService

<h3>Work List</h3>

<div>
    <div>
        <ul class="nav nav-tabs">
            @foreach (var party in tabParties)
            {
                <li class="nav-item">
                    <button class="nav-link @(party.PartyId == partyId ? "active" : "")"
                            @onclick="() => partyId = party.PartyId">
                        @party.Name
                        <i class="bi bi-x text-danger pointer" @onclick:stopPropagation @onclick="e => RemoveParty(party)"></i>
                    </button>
                </li>
            }
            @if (tabParties.Count == 0)
            {
                <li>
                    <button type="button" class="btn btn-outline-light" @onclick="e => buyerSelectModal?.Show()">
                        <i class="bi bi-plus-circle pointer ms-2"></i>
                        @Loc["Add Party Tab"]"
                    </button>
                </li>
            }
            else
            {
                <li><i class="bi bi-plus-circle pointer ms-2" @onclick="e => buyerSelectModal?.Show()"></i></li>
            }
        </ul>
    </div>

    @foreach (var party in tabParties)
    {
        <div class="tab-content @(party.PartyId == partyId ? "show active" : "visually-hidden")">
            @if (workEntrySnapShot != null && workEntrySnapShot.EntriesByParty.ContainsKey(party.PartyId))
            {
                <WorkEntriesComponent DtoWorkEntries="workEntrySnapShot.EntriesByParty[party.PartyId]"
                                      PartyId="@party.PartyId"
                                      ColumnCount="@columnCount"
                                      OnFieldChanged="FieldChanged"
                                      OnDelete="DeleteEntry" />
            }
        </div>
    }
</div>

<div>
    <DebugWorkList @ref="debugWorkList" />
</div>

<BuyerSelectModal @ref="buyerSelectModal" Parties="parties"
                  OnSelected="PartySelected" />

@code {
    int columnCount = 5;
    List<PartyListDto> parties = [];
    List<PartyListDto> tabParties = [];
    int partyId = 0;
    int currentPartyId = 0;
    bool hasTempEntries;
    Lock updateLock = new();

    WorkEntrySnapShot? workEntrySnapShot;

    Dictionary<int, List<WorkEntryWeb>> tempEntries = new();
    HashSet<Guid> savedGuids = [];
    BuyerSelectModal? buyerSelectModal;
    DebugWorkList? debugWorkList;

    protected override async Task OnInitializedAsync()
    {
        parties = await InvoiceRepository.GetBuyers(new());
        await LoadSnapShot();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("registerCustomKeydownEvent");
        }
    }

    private async Task LoadSnapShot()
    {
        workEntrySnapShot = await WorkListRepository.GetWorkEntries();
    }

    private void PartySelected(int selectedPartyId)
    {
        var party = parties.FirstOrDefault(p => p.PartyId == selectedPartyId);
        if (party is null)
        {
            return;
        }
        var tabParty = tabParties.FirstOrDefault(p => p.PartyId == selectedPartyId);
        if (tabParty == null)
        {
            tabParties.Add(party);
        }
        if (!workEntrySnapShot?.EntriesByParty.ContainsKey(selectedPartyId) ?? false)
        {
            workEntrySnapShot?.EntriesByParty.Add(selectedPartyId, []);
        }
        partyId = selectedPartyId;
        InvokeAsync(StateHasChanged);
    }

    private void RemoveParty(PartyListDto party)
    {
        if (tabParties.Contains(party))
        {
            tabParties.Remove(party);
            if (partyId == party.PartyId)
            {
                partyId = tabParties.FirstOrDefault()?.PartyId ?? 0;
            }
        }
    }

    private async Task FieldChanged(WorkEntryWeb entry)
    {
        if (workEntrySnapShot == null)
        {
            return;
        }
        lock (updateLock)
        {
            if (workEntrySnapShot.EntriesByParty.TryGetValue(entry.PartyId, out var entries))
            {
                var existingEntry = entries.FirstOrDefault(f => f.EntryGuid == entry.EntryGuid);
                if (existingEntry != null)
                {
                    entry.UpdateDto(existingEntry);
                }
                else
                {
                    entries.Add(entry.GetDto());
                }
            }
            else
            {
                workEntrySnapShot.EntriesByParty[entry.PartyId] = [entry.GetDto()];
            }
        }
        debugWorkList?.Update(workEntrySnapShot.EntriesByParty[entry.PartyId]);
    }

    private void DeleteEntry(WorkEntryWeb entry)
    {
        if (workEntrySnapShot?.EntriesByParty.TryGetValue(partyId, out var entries) == true)
        {
            var entryToRemove = entries.FirstOrDefault(e => e.EntryGuid == entry.EntryGuid);
            if (entryToRemove != null)
            {
                entries.Remove(entryToRemove);
            }
        }
    }

    private async Task SaveEntries()
    {
        if (workEntrySnapShot == null)
        {
            ToastService.ShowError(Loc["No work entries loaded."]);
            return;
        }
        await WorkListRepository.SaveWorkEntries(workEntrySnapShot);
        ToastService.ShowSuccess(Loc["Work entries saved successfully."]);
    }
}