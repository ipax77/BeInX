@using BlazorInvoice.Shared
@using BlazorInvoice.Shared.Interfaces
@using BlazorInvoice.Weblib.Services
@using System.Collections.Frozen
@using Microsoft.JSInterop
@inherits InvoiceBaseComponent
@inject IInvoiceRepository InvoiceRepository
@inject IWorkListRepository WorkListRepository
@inject IJSRuntime JSRuntime

<h3>Work List</h3>
<div class="mb-4" style="max-width: 400px;">
    <h5>@Loc["Select or Create Buyer"]</h5>
    <select class="form-select" @bind="partyId" @bind:after="OnPartySelected">
        <option value="0">-- Select party --</option>
        @foreach (var party in parties)
        {
            <option value="@party.PartyId">@party.Name</option>
        }
    </select>
</div>

<h3>Entries @focusedRow|@focusedColumn @keyPressed</h3>
<div class="table-responsive">
    <table class="table table-bordered table-sm align-middle text-center">
        <colgroup>
            <col class="col-1">
            <col class="col" style="min-width: 200px;">
            <col class="col-1">
            <col class="col-1">
            <col class="col-1">
            <col class="col-2">
        </colgroup>
        <thead class="table-light">
            <tr>
                <th>Date</th>
                <th>Job</th>
                <th>Start</th>
                <th>End</th>
                <th>â‚¬/h</th>
                <th>Summary</th>
            </tr>
        </thead>
        <tbody @onfocusout="HandleFocusOut" tabindex="0">
            @for (int row = 0; row < workEntries.Count; row++)
            {
                var entry = workEntries[row];
                var rowIndex = row;
                entry.Row = rowIndex;
                <WorkListRow Entry="@entry" RowIndex="@rowIndex"
                             OnKeyPressed="KeyPressed"
                             OnFieldChanged="OnFieldChanged"
                             OnFocus="Focus" />
            }
        </tbody>
        <tfoot>
            <tr>
                <td colspan="4" class="text-start"><button type="button" class="btn btn-sm btn-outline-light" @onclick="AddLine">Add Line</button></td>
                <td class="text-end">Total:</td>
                <td>@(workEntries.Sum(e => (double)e.HourlyRate * (e.EndTime - e.StartTime).TotalHours).ToString("N2"))</td>
            </tr>
        </tfoot>
    </table>
</div>

@code {
    int columnCount = 5;
    List<PartyListDto> parties = [];
    int partyId = 0;
    List<WorkEntryWeb> workEntries = [];
    bool hasTempEntries;
    int focusedRow = -1;
    int focusedColumn = -1;
    string keyPressed = string.Empty;
    private FrozenDictionary<string, bool> interestKeys = new Dictionary<string, bool>() {
        { "ArrowUp", false },
        { "ArrowDown", false },
        { "ArrowLeft", false },
        { "ArrowRight", false },
        { "Tab", false },
    }.ToFrozenDictionary();

    protected override async Task OnInitializedAsync()
    {
        parties = await InvoiceRepository.GetBuyers(new());
        for (int i = 0; i < 10; i++)
        {
            workEntries.Add(new(new() { Date = DateOnly.FromDateTime(DateTime.Today) }, columnCount));
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("registerCustomKeydownEvent");
        }
    }

    private async Task OnPartySelected()
    {
        hasTempEntries = await WorkListRepository.HasTempWorkEntries(partyId);
        // TODO: notify -> continue question

        var entries = await WorkListRepository.GetWorkEntires(partyId, false);
        workEntries = entries.Select(e => new WorkEntryWeb(e, columnCount)).ToList();
        workEntries.Add(new(new() { Date = DateOnly.FromDateTime(DateTime.Today) }, columnCount));
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnFieldChanged(WorkEntryDto entry)
    {
        await WorkListRepository
            .SaveTempWorkEntriesAsync(workEntries.Select(s => s.GetDto()).ToList(), partyId);
    }

    private void AddLine()
    {
        workEntries.Add(new(new() { Date = DateOnly.FromDateTime(DateTime.Today) }, columnCount));
    }

    private void Focus((int, int) info)
    {
        focusedRow = info.Item1;
        focusedColumn = info.Item2;
    }

    private async Task KeyPressed(KeyboardEventArgs e)
    {
        if (!interestKeys.ContainsKey(e.Code))
        {
            return;
        }
        keyPressed = e.Key; // For debugging or display

        if (focusedRow < 0 || focusedColumn < 0) return;

        var current = workEntries.FirstOrDefault(x => x.Row == focusedRow);
        if (current == null) return;
        var currentElement = current.ElementReferences[focusedColumn];
        ElementReference? next = null;

        if (e.Code == "ArrowDown" && focusedRow < workEntries.Count - 1)
        {
            next = workEntries[focusedRow + 1].ElementReferences[focusedColumn];
            focusedRow++;
        }
        else if (e.Code == "ArrowUp" && focusedRow > 0)
        {
            next = workEntries[focusedRow - 1].ElementReferences[focusedColumn];
            focusedRow--;
        }
        else if (e.Code == "ArrowRight" || (e.Code == "Tab" && !e.ShiftKey))
        {
            if (focusedColumn < columnCount - 1)
            {
                next = current.ElementReferences[focusedColumn + 1];
                focusedColumn++;
            }
            else if (focusedRow < workEntries.Count - 1)
            {
                next = workEntries[focusedRow + 1].ElementReferences[0];
                focusedRow++;
                focusedColumn = 0;
            }
        }
        else if (e.Code == "ArrowLeft" || (e.Code == "Tab" && e.ShiftKey))
        {
            if (focusedColumn > 0)
            {
                next = current.ElementReferences[focusedColumn - 1];
                focusedColumn--;
            }
            else if (focusedRow > 0)
            {
                next = workEntries[focusedRow - 1].ElementReferences[columnCount - 1];
                focusedRow--;
                focusedColumn = columnCount - 1;
            }
        }

        if (next.HasValue)
        {
            await next.Value.FocusAsync();
        }
    }

    private void HandleFocusOut()
    {
        focusedRow = -1;
        focusedColumn = -1;
    }
}