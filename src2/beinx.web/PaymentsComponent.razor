@page "/payments"
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.Extensions.Localization
@using Microsoft.JSInterop
@using beinx.loc
@using beinx.shared
@using beinx.shared.Interfaces
@using beinx.web.Forms
@using pax.XRechnung.NET.AnnotatedDtos
@inject IPaymentsRepository PaymentsRepository
@inject IStringLocalizer<InvoiceLoc> Loc
@inject IJSRuntime JSRuntime
@implements IDisposable

<h3>Payments</h3>

@if (isLoading)
{
    <p><em>Loading...</em></p>
}
else
{
    @if (isEditing)
    {
        @if (editingId == null)
        {
            <h3>@Loc["Create New Payment Means"]</h3>
        }
        else
        {
            <h3>@Loc["Edit Payment Means"]</h3>
        }
        <CascadingValue Value="editContext" Name="paymentEditContext">
        <PaymentForm Payment="@currentPayment"
                     OnValidSubmit="@SavePayment"
                     OnCancel="@CancelEdit"
                     OnCodeListRequested="@ShowCodeList" />
        </CascadingValue>
    }
    else
    {
        <button class="btn btn-primary mb-3" @onclick="NewPayment">@Loc["Add New Payment Means"]</button>

        @if (payments.Count == 0)
        {
            <p>No payments found.</p>
        }
        else
        {
            <table class="table table-striped">
                <thead>
                    <tr>
                        <th>Bank Name</th>
                        <th>IBAN</th>
                        <th>BIC</th>
                        <th>Type</th>
                        <th></th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var p in payments)
                    {
                        <tr>
                            <td>@p.Payment.Name</td>
                            <td>@p.Payment.Iban</td>
                            <td>@p.Payment.Bic</td>
                            <td>@p.Payment.PaymentMeansTypeCode</td>
                            <td>
                                <button class="btn btn-sm btn-outline-secondary me-1" @onclick="() => EditPayment(p)">Edit</button>
                                <button class="btn btn-sm btn-outline-danger" @onclick="() => DeletePayment(p.Id)">Delete</button>
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
        }
    }
}

@code {
    private List<PaymentMeansEntity> payments = new();
    private bool isLoading = true;
    private bool isEditing = false;
    private PaymentAnnotationDto currentPayment = new();
    private int? editingId = null;
    EditContext editContext = null!;
    private SemaphoreSlim darftSs = new(1, 1);

    protected override async Task OnInitializedAsync()
    {
        editContext = new EditContext(currentPayment);
        await LoadPaymentsAsync();
        var draft = await PaymentsRepository.LoadDraftAsync();
        if (draft is not null)
        {
            bool restore = await JSRuntime.InvokeAsync<bool>("confirm", "A draft was found. Restore it?");
            if (restore)
            {
                currentPayment = draft.Data;
                editingId = draft.EntityId > 0 ? draft.EntityId : null;
                UpdateContext();
                isEditing = true;
            }
            else
            {
				await PaymentsRepository.ClearDraftAsync();
            }
        }
    }

    private async Task LoadPaymentsAsync()
    {
        isLoading = true;
        await InvokeAsync(StateHasChanged);
        payments = await PaymentsRepository.GetAllAsync();
        isLoading = false;
        await InvokeAsync(StateHasChanged);
    }

    private void NewPayment()
    {
        currentPayment = new PaymentAnnotationDto();
        editingId = null;
        UpdateContext();
        isEditing = true;
    }

    private void EditPayment(PaymentMeansEntity entity)
    {
        currentPayment = new PaymentAnnotationDto
        {
            Name = entity.Payment.Name,
            Iban = entity.Payment.Iban,
            Bic = entity.Payment.Bic,
            PaymentMeansTypeCode = entity.Payment.PaymentMeansTypeCode
        };
        editingId = entity.Id;
        UpdateContext();
        isEditing = true;
    }

    private async Task SavePayment(PaymentAnnotationDto dto)
    {
        if (editingId is null)
        {
            var id = await PaymentsRepository.CreateAsync(dto);
            payments.Add(new PaymentMeansEntity { Id = id, Payment = dto });
        }
        else
        {
            var existing = payments.FirstOrDefault(p => p.Id == editingId);
            if (existing is not null)
                existing.Payment = dto;
            await PaymentsRepository.UpdateAsync(new PaymentMeansEntity { Id = editingId.Value, Payment = dto });
        }
        await PaymentsRepository.ClearDraftAsync();
        isEditing = false;
    }


    private void CancelEdit()
    {
        PaymentsRepository.ClearDraftAsync();
        isEditing = false;
    }

    private async Task DeletePayment(int? id)
    {
        if (!id.HasValue)
			return;
        await PaymentsRepository.DeleteAsync(id.Value);
        payments.RemoveAll(p => p.Id == id.Value);
    }


    private void ShowCodeList(string listName)
    {
        // optional: open modal or code picker
    }

    private void UpdateContext()
    {
        editContext.OnFieldChanged -= FieldChanged;
        editContext = new EditContext(currentPayment);
        editContext.OnFieldChanged += FieldChanged;
    }

    private void FieldChanged(object? sender, FieldChangedEventArgs e)
    {
        _ = SaveDraft();
    }

    private async Task SaveDraft()
    {
        await darftSs.WaitAsync();
        try
        {
            await PaymentsRepository.SaveDraftAsync(currentPayment, editingId);
        }
        finally
        {
            darftSs.Release();
		}
    }

    public void Dispose()
    {
        editContext.OnFieldChanged -= FieldChanged;
	}
}
